.form.bg-primary.h-100v
	.containe.text-center.d-flex.flex-column.p-0
		.d-flex.w-full.justify-content-between.align-items-center
			div
			.form-logo
				 = image_tag "temp-logo.svg"
			= link_to root_path do
				i.form-back.fas.fa-arrow-right.fa-2x.icon-secondary

		h1.question ?כמה זמן יש לך למשחק
		.answers.d-flex.flex-wrap.w-100.justify-content-center
			.answer.bg-secondary.rounded.m-4.d-flex.justify-content-center.align-items-center דקות 5
			.answer.bg-secondary.rounded.m-4.d-flex.justify-content-center.align-items-center 10 דקות
			.answer.bg-secondary.rounded.m-4.d-flex.justify-content-center.align-items-center 15 דקות
			.answer.bg-secondary.rounded.m-4.d-flex.justify-content-center.align-items-center 20+ דקות

.form-games.bg-primary.h-12v.form-rounded.text-center.text-white.resizablea. style="height: 85vh !important"
	.game-card data-next="" data-prev=""
		i.fas.fa-grip-lines.fa-2x.grip
		h2.game-name.pt-2#get_game נקניק
		.flex.justify-content-center.w-100.align-items-center.flex-column
			.description.game-attrs.w-75.text-right#get_description.d-none תיאור ממש טוב למשחק שנקרא נקניק
			.how-to.game-attrs.w-75.text-right#get_how_to.d-none איך משחקים
	#board
		/ .card

/ .append
/ #board
/ 	.card
/ #slider.swipe.h-100v
/   .swipe-wrap
/     .h-1.w-1.bg-success
/     .h-1.w-1.bg-danger
/     .h-1.w-1.bg-warning
/ .h-100v
/ 	.draggable Draggable Element
javascript:


	// import Swipe from 'swipejs'
	// const position = { x: 0, y: 0 }
	//
	// interact('.draggable').draggable({
	// 	startAxis: 'y',
  // 	lockAxis: 'start',
	//   listeners: {
	//     start (event) {
	//       console.log(event.type, event.target)
	//     },
	//     move (event) {
	//       position.x += event.dx
	//       position.y += event.dy
	//
	//       event.target.style.transform =
	//         `translate(${position.x}px, ${position.y}px)`
	//     },
	//   }
	//
	// })bac
	var up_or_down
	var original_question = $(".question").offset().top
	var original_top = $(".form-games").offset().top
	var original_font_size = $(".form-back").css('font-size')
	var original_logo_position = $(".form-logo").children('img').offset().top
	interact('.resizable')
	  .resizable({
			inertia: true,
	    edges: {
	      top   : ".grip",
	      left  : false,
	      bottom: false,
	      right : false
	    },
	  })
	  .on('resizemove', event => {
			// console.log($(event.target).height());
			if ($(event.target).height() > $(document).height()/5) {
				$(".game-attrs").removeClass('d-none').css('display', 'inline-block').addClass('transparent');
				var opacity
				if (parseInt($(event.target).height()/$(document).height()*100) >= 70) {
					opacity = 1
				}else {
					opacity = $(event.target).height()/$(document).height()

				}
				$(".game-attrs").css('opacity', opacity);
			}else {
				$(".game-attrs").addClass('d-none')

			}
			let { x, y } = event.target.dataset


	    x = parseFloat(x) || 0
	    y = parseFloat(y) || 0

			var top = $(event.target).offset().top
			var question = $(".question").offset().top + $(".question").height()
			// console.log("up_or_down: " + up_or_down);
			// console.log("top: " + top);
			var up
			if (top > up_or_down) {
				up = false
			}else if (top < up_or_down) {
				up = true

			}
			console.log($(".form-back").css('font-size'));
			if (top <= question + 40 && up) {
				$(".question").offset({top: $(".question").offset().top - 4})
				$(".form-logo").children('img').height(($(".form-logo").children('img').height() - 4))
				if ($(".form-logo").children('img').height() <= $(document).height()/15 ) {
					// console.log("tiny");
					$(".form-logo").children('img').offset({top: $(".form-logo").children('img').offset().top - 2})
					$(".form-back").css('font-size', parseInt($(".form-back").css('font-size')) - 2 + 'px')
				}
				// console.log($(".form-logo").children('img').height);
			}else {
				if ($(".question").offset().top == original_question) {
					$(".question").offset({top: $(".question").offset().top + 4})

				}
				$(".form-logo").children('img').height(($(".form-logo").children('img').height() + 4))
				if ($(".form-logo").children('img').height() <= $(document).height()/15 ) {
					// console.log("tiny");
					$(".form-logo").children('img').offset({top: $(".form-logo").children('img').offset().top + 2})

					$(".form-back").css('font-size', parseInt($(".form-back").css('font-size')) + 2 + 'px')

			}

			}
			// console.log(question);
			// if (event.target) {
			// 	console.log();
			// }
	    Object.assign(event.target.style, {
	      width: `${event.rect.width}px`,
	      height: `${event.rect.height}px`,
	      transform: `translate(${event.deltaRect.left}px, ${event.deltaRect.top}px)`
	    })
	    Object.assign(event.target.dataset, { x, y })
			if (parseInt($(event.target).offset().top) % 4 == 0) {
				up_or_down = $(event.target).offset().top
			}
	  })

	var element = document.getElementById('slider');
	window.mySwipe = new Swipe(element, {
	  startSlide: 1,
	  auto: false,
	  draggable: true,
	  autoRestart: true,
	  continuous: true,
	  disableScroll: true,
	  stopPropagation: true,
	  callback: function(index, element) {},
	  transitionEnd: function(index, element) {}
	});

	$(function() {
		Cookies.set('tags', ["5 דקות"] );
		// console.log( $('#get_game').html() );
		$.ajax({
		 type: "GET",
		 dataType: "json",
		 data: { tags: Cookies.getJSON('tags') },
		 url: "/filter_tag",
		 success: function(data){
			 // console.log(data);
			 $.each(data.reverse(), function(index, game) {
				 carousel.push(game)

			 });
			 carousel.handle()
			 console.log();
			 // console.log(carousel.topCard);
			 $('#get_game').html(data[0].name)
			 $('.game-card').attr('data-next', 1)
			 $('#get_description').html(data[0].description)
			 $('#get_how_to').html(data[0].how_to)

	  }})
	});

	counter = 1
	class Carousel {
			constructor(element) {

					this.board = element

					// add first two cards programmatically
					// this.push()
					// this.push()

					// handle gestures
					this.handle()

			}

			handle() {

					// list all cards
					this.cards = this.board.querySelectorAll('.card')
					// console.log(this.board.querySelectorAll('.topCard')	);
					// get top card
					// this.topCard = this.cards[this.cards.length - 1]
					// this.topCard = this.cards.classList.contains('topCard')
					// console.log(this.topCard);
					// console.log($(this).children('.topCard').first());
					this.topCard = this.cards[this.cards.length - counter]
					// console.log(counter);
					// console.log(this.cards);
					// console.log(this.topCard);
					// console.log(this.topCard);

					// get next card
					this.nextCard = this.cards[this.cards.length - 2]
					this.prevCard = this.cards[this.cards.length - counter + 1]
					this.lastCard = this.cards[0]
					console.log(this.prevCard);

					// if at least one card is present
					if (this.cards.length > 0) {

							// set default top card position and scale
							this.topCard.style.transform =
									'translateX(-50%) translateY(-50%) rotate(0deg) rotateY(0deg) scale(1)'

							// destroy previous Hammer instance, if present
							if (this.hammer) this.hammer.destroy()

							// listen for tap and pan gestures on top card
							this.hammer = new Hammer(this.topCard)
							this.hammer.add(new Hammer.Tap())
							this.hammer.add(new Hammer.Pan({
									position: Hammer.position_ALL,
									threshold: 0
							}))

							// pass events data to custom callbacks
							this.hammer.on('tap', (e) => {
									this.onTap(e)
							})
							this.hammer.on('pan', (e) => {
									this.onPan(e)
							})

					}

			}

			onTap(e) {
					console.log("tap");
					// get finger position on top card
					let propX = (e.center.x - e.target.getBoundingClientRect().left) / e.target.clientWidth

					// get rotation degrees around Y axis (+/- 15) based on finger position
					let rotateY = 15 * (propX < 0.05 ? -1 : 1)

					// enable transform transition
					this.topCard.style.transition = 'transform 100ms ease-out'

					// apply rotation around Y axis
					this.topCard.style.transform =
							'translateX(-50%) translateY(-50%) rotate(0deg) rotateY(' + rotateY + 'deg) scale(1)'

					// wait for transition end
					setTimeout(() => {
							// reset transform properties
							this.topCard.style.transform =
									'translateX(-50%) translateY(-50%) rotate(0deg) rotateY(0deg) scale(1)'
					}, 100)

			}

			onPan(e) {
				// console.log("pan");
					if (!this.isPanning) {

							this.isPanning = true

							// remove transition properties
							this.topCard.style.transition = null
							if (this.nextCard) this.nextCard.style.transition = null

							// get top card coordinates in pixels
							let style = window.getComputedStyle(this.topCard)
							let mx = style.transform.match(/^matrix\((.+)\)$/)
							this.startPosX = mx ? parseFloat(mx[1].split(', ')[4]) : 0
							this.startPosY = mx ? parseFloat(mx[1].split(', ')[5]) : 0

							// get top card bounds
							let bounds = this.topCard.getBoundingClientRect()

							// get finger position on top card, top (1) or bottom (-1)
							this.isDraggingFrom =
									(e.center.y - bounds.top) > this.topCard.clientHeight / 2 ? -1 : 1

					}

					// get new coordinates
					let posX = e.deltaX + this.startPosX
					let posY = e.deltaY + this.startPosY
					if (e.deltaX > 0) {
						console.log("right");
					} else {
						console.log("left");
						// Get the parent element.
						// console.log( this.cards)
						console.log(typeof(this.prevCard));
						console.log(this.board.childNodes[0]);
						// this.board.insertBefore(this.prevCard, this.TopCard);
						// const parent = document.getElementById('board');
						// // Shallow copy to array: get a `reverse` method.
						// const arr = Array.from(parent.childNodes);
						// // `reverse` works in place but conveniently returns the array for chaining.
						// arr.reverse();
						// // The experimental (as of 2018) `append` appends all its arguments in the order they are given. An already existing parent-child relationship (as in this case) is "overwritten", i.e. the node to append is cut from and re-inserted into the DOM.
						// parent.append(...arr);
					}
					// get ratio between swiped pixels and the axes
					let propX = e.deltaX / this.board.clientWidth
					let propY = e.deltaY / this.board.clientHeight

					// get swipe direction, left (-1) or right (1)
					let dirX = e.deltaX < 0 ? -1 : 1

					// get degrees of rotation, between 0 and +/- 45
					let deg = this.isDraggingFrom * dirX * Math.abs(propX) * 45

					// get scale ratio, between .95 and 1
					let scale = (95 + (5 * Math.abs(propX))) / 100

					// move and rotate top card
					this.topCard.style.transform =
							'translateX(' + posX + 'px) translateY(-50%) rotate(' + deg + 'deg) rotateY(0deg) scale(1)'

					// scale up next card
					// if (this.nextCard) this.nextCard.style.transform =
					// 		'translateX(-50%) translateY(-50%) rotate(0deg) rotateY(0deg) scale(' + scale + ')'

					if (e.isFinal) {
							this.isPanning = false

							let successful = false

							// set back transition properties
							this.topCard.style.transition = 'transform 200ms ease-out'
							if (this.nextCard){
								// this.nextCard.style.transition = 'transform 100ms linear'

							} else {
								console.log("fianl");
							}

							// check threshold and movement direction
							if (propX > 0.25 && e.direction == Hammer.DIRECTION_RIGHT) {

									successful = true
									// get right border position
									posX = this.board.clientWidth

							} else if (propX < -0.25 && e.direction == Hammer.DIRECTION_LEFT) {

									successful = true
									// get left border position
									posX = -(this.board.clientWidth + this.topCard.clientWidth)

							} else if (propY < -0.25 && e.direction == Hammer.DIRECTION_UP) {

									successful = true
									// get top border position
									posY = -(this.board.clientHeight + this.topCard.clientHeight)

							}

							if (successful) {

									// throw card in the chosen direction
									this.topCard.style.transform =
											'translateX(' + posX + 'px) translateY(' + posY + 'px) rotate(' + deg + 'deg)'

									// wait transition end
									setTimeout(() => {
											// remove swiped card

											// this.board.removeChild(this.topCard)
											$(this.topCard).addClass('d-none')
											// this.topCard = this.board.querySelectorAll('.topCard')[0]
											// var new_top = $(".card").indexOf($(".card").first())
											// var topCards = $(".topCard")
											counter++
											if (counter == this.cards.length + 1) {
												console.log(counter);
												counter = 1
												// $(".card").first().insertAfter($(".card").last());
												$.each($(".card"), function(index, el) {
													$(el).removeClass('d-none')

													el.style.transform =
															'translateX(-50%) translateY(-50%) rotate(0deg) rotateY(0deg) scale(1)'
												})
											}
											// $(".topCard").eq(0).removeClass('topCard')
											// $(".card").eq(1).addClass('topCard')
											// topCards[0]
											// .first()
											// console.log($(".card")[1]);
											// $(".card")[1].addClass('.topCard')
											// add new card
											// this.push()
											// handle gestures on new top card
											this.handle()
									}, 200)

							} else {

									// reset cards position and size
									this.topCard.style.transform =
											'translateX(-50%) translateY(-50%) rotate(0deg) rotateY(0deg) scale(1)'
									// if (this.nextCard) this.nextCard.style.transform =
									// 		'translateX(-50%) translateY(-50%) rotate(0deg) rotateY(0deg) scale(0.95)'

							}

					}

			}

			push(game) {

					let card = document.createElement('div')

					card.classList.add('card')
					card.innerHTML = game.id
					card.id = "game" + game.id
					// $(card).append(
					// 	""
					// )
					// card.style.backgroundImage =
					// 		"url('https://picsum.photos/320/320/?random=" + Math.round(Math.random() * 1000000) + "')"

					this.board.insertBefore(card, this.board.firstChild)

			}

		}


			let board = document.querySelector('#board')
			let carousel = new Carousel(board)

	// console.log(carousel);
